import collections
import errno
import glob
import inspect
import logging
import os
import sys
import traceback
from . import config
LOGGER = logging.getLogger(__name__)
LOGGER.addHandler(logging.NullHandler())  # Handle logging, no logging has been configured
DEBUG = config.get_config_key('debug_mode')     #LOGGER.isEnabledFor(logging.DEBUG)
# LOGGER.setLevel(logging.DEBUG)

def getIncrementingFilename(folder='', ext='', prefix='', suffix='', sep='_'):
    """
    Generate a unique incrementing filename.

    This will generate a placeholder file in the specified folder which can be overwritten.
    This is usefull for maintaining the order that files are created during processing.

    Args:
        folder (str): The folder to create the file in. This folder must already exist.
        ext (str)   : The extension of the file.
        prefix (str): The prefix for the filename
        suffix (str): the sufix for the file name. at a minimum it should be the required extension including the dot
        sep (str): the string used to separate the prefix & incrementing number and suffix.

    Returns:
        filename(str)
    """
    if not os.path.exists(folder):
        raise IOError('Folder {} does not exist'.format(folder))

    if '.' not in ext:
        ext = '.' + ext

    files = glob.glob(os.path.join(folder, '{}*'.format(prefix)))

    # remove extensions (ie .prj, shx etc) and sort to remove duplicates
    files = sorted([os.path.splitext(ea)[0] for ea in files])

    # generate the incrementing filename
    file = '{}{s}{:02d}{s}{}{}'.format(prefix, len(files) + 1, suffix, ext, s=sep)

    filename = os.path.join(folder, file)

    return filename


def print_functions_string(frame, classname=None):
    """ Print to screen the input function and args.
    adapted from http://stackoverflow.com/a/582206

    Returned classes will be identified with ++, and all input args with + to help differentiate between other args.
    Args:
        frame (frame): The frame from the current function
        classname(): The current name of the class
    Returns:
        None: List (str)
    """
    try:
        args, _, _, values = inspect.getargvalues(frame)
        mess = []

        if classname:
            mess.append('++{}.{}'.format(classname, inspect.getframeinfo(frame)[2]))
        else:
            mess.append('++{}'.format(inspect.getframeinfo(frame)[2]))

        if len(args) > 0:
            # get the length of the longest string in a list to assist with formatting
            varLength = len(max(args, key=len))
            # loop through args and print to screen.
            for varName in args:
                if varName == 'self' and len(args) == 1:
                    mess[0] += '  - No Args'
                elif varName != 'self':
                    if not isinstance(values[varName], (unicode, str, float, long, int, list, dict)):
                        mess.append("    {0:<{2}} {1}".format(varName, type(values[varName]), varLength + 5))
                    else:
                        mess.append("    {0:<{2}} {1}".format(varName, values[varName], varLength + 5))
    except:
        pass
    return mess


def DeleteSpatialFiles(in_filename):
    """ Find and delete files with the same basename but with different extensions.

    It will take a file, remove the extension and delete all files relating to it.
    ie:  all elements of a shapefile ie *.shp *.dbf *.prj etc.
         any files generated by software for display eg. *.aux, *.xml *.tfw etc.

    Args:
        in_filename (str):  The input file to use as a base for deleting.

    Returns:

    """
    fileN, ext = os.path.splitext(in_filename)

    # Find all matching files
    fileList = glob.glob(fileN + '.*')
    if len(fileList) == 0:
        return
    for eaFile in fileList:
        try:
            os.remove(eaFile)
        except OSError as e:  # this would be "except OSError, e:" before Python 2.6
            # logging.exception("An Error Has Occurred")
            exc_type, exc_value, exc_traceback = sys.exc_info()
            mess = str(traceback.format_exc())
            LOGGER.error(mess, exc_info=True)
            print(mess)

            if e.errno != errno.ENOENT:  # errno.ENOENT = no such file or directory
                raise  # re-raise exception if a different error occurred


# These probably wont stay long term its just to improve display for comparison during debugging.
def displayTwoSrs_sidebyside(oSRS1, oSRS2):
    """Take two spatial reference object and print them side-by-side to the console to make it easier to read.

    Args:
        oSRS1 (osgeo.osr.SpatialReference:): A spatial reference
        oSRS2 (osgeo.osr.SpatialReference:): A second spatial reference to compare to the above

    """
    list1 = str(oSRS1).split('\n')
    list2 = str(oSRS2).split('\n')
    diff = len(list1) - len(list2)  # if negative then flist is shorter.
    if diff < 0:  # if negative then flist is shorter.
        list1 += [''] * abs(diff)  # Stuff with blank strings
    elif diff > 0:
        list2 += [''] * abs(diff)

    maxLength = len(max(list1, key=len)) + 5

    print('{0:<{2}} {1}'.format('Original', 'EPSG derived', maxLength))
    print('*' * (maxLength + maxLength))
    for i in range(max(len(list1), len(list2))):
        print('{0:<{2}} {1}'.format(list1[i], list2[i], maxLength))

    print('*' * (maxLength + maxLength))


def displayTableDictionary(oTabDictionary, linePrefixString=''):
    """ Print a table dictionary to screen. Dictionary should be like
             eg = 'BLOCK_NAME', {'width': 25, 'type': 'String', 'precision': 0}
    Args:
        oTabDictionary (object): The column properties object
        linePrefixString   (string): String characters used to offset the start of the line

    """
    # a collection of keys and the max string length for formatting.
    tabFormatDict = collections.defaultdict(int)
    for k, v in oTabDictionary.iteritems():
        tabFormatDict['Name'] = max(len(k), tabFormatDict['Name'])
        for k1, v1 in v.iteritems():
            tabFormatDict[k1] = max(len(str(k1)) + 3,
                                    tabFormatDict[k1])  # add the column name length. with a 3 char buffer
            tabFormatDict[k1] = max(len(str(v1)) + 3, tabFormatDict[k1])  # add the attribute length.

    i = 0
    for key, value in oTabDictionary.iteritems():
        if i == 0:  # build up column name headers, from the dictionary key and apply formatting
            header = '{}{name:{maxLen}}'.format(linePrefixString, maxLen=tabFormatDict['Name'], name='Key')
        # Build up the attributes for each column, and apply formatting
        row = u'{}{name:{maxLen}}'.format(linePrefixString, maxLen=tabFormatDict['Name'], name=key)
        for k, v in value.iteritems():
            if type(v) == str:  # Align Left if string
                alignFormat = '<'
            else:
                alignFormat = '>'

            if i == 0:
                # Add sub key to header row
                header += '   {name:{align}{maxLen}}'.format(linePrefixString, maxLen=tabFormatDict[k], name=k,
                                                             align=alignFormat)
            # add sub values to the attributes for each column, and apply formatting
            row += '   {name:{align}{maxLen}}'.format(maxLen=tabFormatDict[k], name=v, align=alignFormat)

        if i == 0:
            print(header)
            print(linePrefixString + '-' * len(header))

        print(row)
        i += 1
